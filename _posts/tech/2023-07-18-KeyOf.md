---
layout: post
title:  "[WIP] KeyOf"
date:   2023-07-18 12:00:00 +0700
tech: true
---

## TypeScript, a Structurally Typed Language

TypeScript is a statically typed programming language that transpiles to Javascript allowing for engineers to gradually introduce types to an existing, dynamic, duck typed, Javascript codebase. TypeScript is a structurally typed language, which, among other reasons, allows it to best adhere to Javascript idioms and most simply transpile to Javascript objects.

### Some Definitions

According to [Nominal and Structural Typing](http://wiki.c2.com/?NominativeAndStructuralTyping), type compatability is answered via two predicates:

1. **equivalence predicate:** *given two type expressions T1 and T2, are T1 and T2 equivalent? In other words, are all objects of type T2 valid objects of type T1, and vice versa? Commonly written as T1 == T2*
2. **subtype predicate:** *given two type expressions T1 and T2, is T1 a subtype of T2? In other words, are all objects of type T1 also objects of type T2? Commonly written as T1 <= T2*

### Structural vs. Nominal Typing Example

**Structurally typed:** type compatability and equivalence is determined by the structure of the types

**Nominally typed:** type compatability and equivalence is determined by the name of the types

Consider the following example.

```
foo {
    bar: () => string
}

baz {
    bar: () => string
}
```

In a nominally typed language, `foo != bar`, however in a structurally typed language, `foo == bar`.


Note that (according to Wiki.co)
> Nominal typing is a "subset" of structural typing, in that two types cannot be equivalent in a nominal typing system unless they are structurally equivalent (else, the typing system would be unsound). Likewise for the subtype relationship.


**What about Duck Typing?** Duck typing is the most common type of dynamic typing which calls object methods at runtime.

**Which is better?** Put simply, a main pro of nominal typing is differentiation between two types of the same structure, i.e. MeasurementInFeet and MeasurementInMeters. Structural typing is advantageous for its flexibility.

While we're comparing structural and nominal type systems, note _hybrid_ systems (I don't believe this is a techinical term) exist.

Hyrbid (C++):
> At a base level, C++ is nominatively typed--two classes with different names are not considered equivalent; and subtyping must be explicitly declared (via inheritance). However, the template system uses structural typing--any type can be an argument to any template; and the compiler won't complain unless a particular instantiation of a template is incompatible with its declaration. (See LatentTypesSmell for more on this).

A nice table _attempting_ to define which language is which: [Wikipedia](https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system).

### Type Operators

If you've worked in a nominally typed language like Java or C#, you're familiar with introspection, asking an object what its type is with methods like `.class` or `instanceof`.


```java
"hello" instanceof String
```

Furthermore, type _inheritance_ and _extenstion_ is fairly straightforward in nominally typed language; it is typically accomplished explicitly with operators like `extends`, `<`, etc. 


```java
public class Animal {}

public class Jaguar extends Animal {}
```

```java
public interface Food { 
    public bool isTasty();
}

public class HotPastramiSandwich implements Food {
    public bool isTasty() {
        return true;
    }
}
```

In a structurally typed language, an analogous operator is `keyof`. `keyof` returns a concatenated collection of object properties. Since a structure defines the type, in TypeScript, type equality is defined as having the same properties.

```typescript
type Point = { x: number; y: number };

// "x" | "y"
type P = keyof Point;
```

It also has a limited `typeOf` operator as well.

```typescript
type Point = { x: number; y: number };

// typeof pt = Point
const pt: Point = { x: 10, y: 11 }
```

And supports subtyping and interface implementation as so:

```typescript
// interface definition: in TypeScript, describes shape of data. Interfaces can be extended and implemented but we cannot
// create a new one by intersection two together (that is a type).
interface foo {
    isTasty: bool
}

// type definition: in TypeScript, a definition of a data type. Types are aliases for structures. These can be combined, but cannot
// be duplicated or extended.
type Animal = {
    makesNoise: bool
}
```

## Keyof Examples

1. accessing an object in a "safe" way via generic constraints 

```typescript
interface Foo {
    isTasty: boolean;
}

let pizza = { isTasty: true }



function isMyAThing(food: Food, attribute: keyof Food): boolean {
    return food[attribute];
}

isMyAThing(pizza, "isTasty")
isMyAThing(pizza, "isHealthy") // will fail
```

2. map over properties of an existing type

3. in conjunction with utility types (i.e. Record, Pick, etc.) which manipulate the type (since its structural typing, that means manipulating the underlying properties)

4. create new types

***

## Leveraging Keyof to Type Tables

I am most interested in Tables.

What is a table type? It's columns?

If that's the case, we're most interested in leveraging saftey things based on the schema:


* are two tables the same types?
    * schema is same (AND ORDER MATTERS)
* describing table operations that get, delete, add columns (CRUD schema)
* safety of things oeprating on table (does it comply with the schema)

We get a lot of this for free with keyof:
* what rows exist == properties == keyof
* 

***

## References

Most of this post (except for the thoughts on typing tables) is a rephrasing and summary of the following:

* [Structural Typing - Wikipedia](https://en.wikipedia.org/wiki/Structural_type_system)
* [Nominal Typing - Wikipedia](https://en.wikipedia.org/wiki/Nominal_type_system)
* [Type Compatability - TypeScript Handbook](https://www.TypeScriptlang.org/docs/handbook/type-compatibility.html)
* [Nominal and Structural Typing](http://wiki.c2.com/?NominativeAndStructuralTyping)
* [Nominal Typing Proposal TypeScript](https://github.com/Microsoft/TypeScript/issues/202)
* [Comparison of Programming Languages by Type System - Wikipedia](https://en.wikipedia.org/wiki/https://www.oracle.com/technical-resources/articles/java/javareflection.html)
* [Using Reflection in Java](https://www.oracle.com/technical-resources/articles/java/javareflection.html)
* [Implementing an Interface in Java](https://docs.oracle.com/javase/tutorial/java/IandI/usinginterface.html)
* [KeyOf TypeScript](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [Types vs. Interface in TypeScript](https://blog.bitsrc.io/type-vs-interface-in-typescript-cf3c00bc04ae)
* [How to use KeyOf Operator in TypeScript](https://blog.logrocket.com/how-to-use-keyof-operator-typescript/)
* [5 ways to use `keyof` operator in TypeScript](https://byby.dev/ts-keyof)
* [Stackoverflow question about `extend keyof` and `in keyof`](https://stackoverflow.com/questions/57337598/in-typescript-what-do-extends-keyof-and-in-keyof-mean)
* [keyof and Lookup Types in TypeScript](https://mariusschulz.com/blog/keyof-and-lookup-types-in-typescript)
* [Mapped Types in TypeScript](https://mariusschulz.com/blog/mapped-types-in-typescript#modeling-object-freeze-with-mapped-types)
* [Types and Programming Languages - Benjamin C. Pierce - 19.3](https://www.cis.upenn.edu/~bcpierce/tapl/)
