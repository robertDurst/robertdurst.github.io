---
layout: post
title:  "KeyOf"
date:   2023-07-18 12:00:00 +0700
tech: true
---

## TypeScript, a Structurally Typed Language

TypeScript is a statically typed programming language that transpiles to Javascript allowing for engineers to gradually introduce types to an existing, dynamic, duck typed, Javascript codebase or leverage the expansive JavaScript ecosystem with an added layer of protection. TypeScript is a structurally typed language, which, among other reasons, allows it to best adhere to Javascript idioms and most simply transpile to Javascript objects.

Unless you're already familiar with TypeScript's type system, I'd recommend opening up a [TS Playground online editor](https://www.typescriptlang.org/play) in another screen as you read along. 

### Some Definitions

We'll use the term `type compatable` quite often in this post, so let's take a moment to formally define it. As best summed up by [Nominal and Structural Typing](http://wiki.c2.com/?NominativeAndStructuralTyping), type compatability is answered via two predicates:

1. **equivalence:** *given two type expressions T1 and T2, are T1 and T2 equivalent? In other words, are all objects of type T2 valid objects of type T1, and vice versa? Commonly written as T1 == T2*
2. **subtype:** *given two type expressions T1 and T2, is T1 a subtype of T2? In other words, are all objects of type T1 also objects of type T2? Commonly written as T1 <= T2*

If these are true, two types are compatible.

### Structural vs. Nominal Typing

Above I noted that TypeScript is structurally typed. There is also nomial typing, which sits at the other end of the type compatability spectrum.

**Structurally typed:** type compatability is determined by the structure of the types

**Nominally typed:** type compatability is determined by the name of the types

Consider the following example.

```
foo {
    bar: () => string
}

baz {
    bar: () => string
}
```

In a nominally typed language, `foo != bar`, however in a structurally typed language, `foo == bar`.


Note that:
> Nominal typing is a "subset" of structural typing, in that two types cannot be equivalent in a nominal typing system unless they are structurally equivalent (else, the typing system would be unsound). Likewise for the subtype relationship. -- [Nominal and Structural Typing](http://wiki.c2.com/?NominativeAndStructuralTyping)

**What about Duck Typing?** Duck typing is often what we have when we have dynamic typing which calls object methods at runtime.

**Which is better?** Put simply, one of the main pros of nominal typing is differentiation between two types of the same structure, i.e. MeasurementInFeet and MeasurementInMeters. Structural typing is advantageous for its flexibility.

While we're comparing structural and nominal type systems, note _hybrid_ systems (I don't believe this is a techinical term) exist.

> At a base level, C++ is nominatively typed--two classes with different names are not considered equivalent; and subtyping must be explicitly declared (via inheritance). However, the template system uses structural typing--any type can be an argument to any template; and the compiler won't complain unless a particular instantiation of a template is incompatible with its declaration. (See LatentTypesSmell for more on this). -- [Nominal and Structural Typing](http://wiki.c2.com/?NominativeAndStructuralTyping)

A nice table _attempting_ to define which language is which: [Wikipedia](https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system).

### Type Operators

If you've worked in a nominally typed language like Java or C#, you're familiar with introspection, asking an object what its type is with methods like `.class` or `instanceof`.


```java
"hello" instanceof String
```

Furthermore, type _inheritance_ and _extenstion_ is fairly straightforward in nominally typed language; it is typically accomplished explicitly with operators like `extends`, `<`, etc. 


```java
public class Animal {}

public class Jaguar extends Animal {}
```

```java
public interface Food { 
    public bool isTasty();
}

public class HotPastramiSandwich implements Food {
    public bool isTasty() {
        return true;
    }
}
```

In a structurally typed language, an analogous operator is `keyof`. `keyof` returns a concatenated collection of object properties. Since a structure defines the type, in TypeScript, type equality is defined as having the same properties.

```typescript
type Point = { x: number; y: number };

// "x" | "y"
type P = keyof Point;
```

It also has a limited `typeOf` operator as well.

```typescript
type Point = { x: number; y: number };

// typeof pt = Point
const pt: Point = { x: 10, y: 11 }
```

And supports subtyping and interface implementation as so:

```typescript
// interface definition: in TypeScript, describes shape of data. Interfaces can be extended and implemented but we cannot
// create a new one by intersection two together (that is a type).
interface foo {
    isTasty: bool
}

// type definition: in TypeScript, a definition of a data type. Types are aliases for structures. These can be combined, but cannot
// be duplicated or extended.
type Animal = {
    makesNoise: bool
}
```

## Keyof Examples

1. accessing an object in a "safe" way via generic constraints 

```typescript
interface Foo {
    isTasty: boolean;
}

let pizza = { isTasty: true }


function isMyAThing(food: Food, attribute: keyof Food): boolean {
    return food[attribute];
}

isMyAThing(pizza, "isTasty")
isMyAThing(pizza, "isHealthy") // will fail
```

Here `isMyAThing` does two interesting things: (a) indexes properties of a type (b) constrains input of attribute to just being valid properties of `Food`.

2. map over properties of an existing type

```typescript
type Boolify<T> = {
    [K in keyof T]: boolean
} 

interface SomethingUseful {
    name: string;
    age: number;
}

type SomethingLessUseful = Boolify<SomethingUseful>;

let notHelpful: SomethingLessUseful = { name: true, age: false };
```

Here `Boolify` maps all properties of the generic `T` to `boolean`s,

3. in conjunction with utility types (i.e. Record, Pick, etc.) which manipulate the type (since its structural typing, that means manipulating the underlying properties)

Consider `Record`: which *constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type* more formally `Record<Keys, Type>`.

```typescript
type Qualities = {
    isTasty: boolean;
    isHealthy: boolean;
    calories: number;
}

interface Info {
    value: string
}

type Food = Record<keyof Qualities, Info>;

const asparagus: Food = {
    isTasty: { value: "sometimes" },
    isHealthy: { value: "yes!" },
    calories: { value: "idk" }
}
```

4. create new types

```typescript
type Food = {
    isTasty: boolean;
}

type Decoration = {
    isPretty: boolean;
}

type DecorativeFood = Food & Decoration;

const weddingCake: DecorativeFood = {
    isTasty: true,
    isPretty: true,
}

type DecorationOrFood = Food | Decoration;

const bacon: DecorationOrFood = {
    isTasty: true
};
const painting: DecorationOrFood =  {
    isPretty: true
}

type DecorationOrFoodDescription = keyof Food | keyof Decoration;

const bacon: DecorationOrFood = 'isTasty'
const painting: DecorationOrFoodDescription =  'isPretty'
```

***

## Leveraging Keyof to Type Tables

From [Types for Tables: A Language Design Benchmark - 3.1](https://cs.brown.edu/~sk/Publications/Papers/Published/lgk-b2t2/paper.pdf), we have the following definitions:

* **table**: a schema and a rectangular collection of cells.
* **schema**: an ordered, unique sequence of column names and corresponding sorts.
* **header**: a sequence of distinct column names (a schema without sorts).
* **column name**: is a string-like first-class datatype.
* **sort**: describes the kind of data that a cell may contain.
* **collection of cells**: has C ∗ R members, where: C is the length of the schema, R is an arbitrarily-large number of rows, and each cell has a unique index (c,r) for 0 ≤ c < C and 0 ≤ r < R. The rectangular arrangement has four important consequences: the rows are ordered, the columns are indexable by schema, all columns contain exactly R cells, and all rows contain exactly C cells.
* **row**: is an ordered sequence of cells.
* **cell**: is a container for data. It may be empty and the data in cells of column c must match the sort of the c-th element of the
schema.

So what is a table type? Based on the above, it is a an ordered sequence of labeled types. Thus, we're most interested in leveraging saftey things based on the schema.

Stepping back, what do we care about for tables:

* type compatability
    * equivalence: is this table T1 the same as this other table T2?
    * subtype: for some table T1 and another T2, are all tables T1 tables T2? (the reverse need not be true)
* static, schema based validations for:
    * CRUD'ing rows
    * CRUD'ing columns

Nominally, it would look a bit like this:

* get-headers: `Table -> [] string`
* compare tables:
    * is-subtype: `Table -> Table -> Bool`
    * is-instance-of: `Table -> Table -> Bool`
* CRUD columns:
    * get-column: `Table -> Column Name -> Column`
    * add-column: `Table -> Column -> Table`
    * delete-column: `Table -> Column Name -> Table`
* CRUD rows:
    * get-row: `Table -> Number -> Row`
    * add-row: `Table -> Row -> Table`
    * delete-row: `Table -> Number -> Table`

Today's Pyret supports this via branding.

Structurally, it would look a bit like this:

```pyret
EmptyTable: { }

SORT = string | number | etc.
Schema: Record<ColumnName, SORT>

ColumnName = SingletonString
TOP = top

Column = [ColumnName; TOP]

! :: Not in?
```

* get-headers<T1>: `keyof T1`
* compare tables:
    * is-subtype:
    * is-instance-of:
* CRUD columns:
    <!-- get-column :: some Table -> some column name from table -> the column for that column name -->
    * get-column<T1>: `Schema -> keyof Schema -> SORT`
    <!-- add-column :: some Table -> some tuple with a column name not in the table and an acceptable sort -> the table with this new column -->
    * add-column<T1>: `Schema -> [keyof Schema; SORT] -> Schema & [keyof Schema; SORT]`
    <!-- delete-column :: some Table -> some column name from table -> the table without that column -->
    * delete-column<T1>: `Schema -> keyof Schema -> Schema & Omit<keyof Schema, SORT>`
* CRUD rows:
    * get-row:
    * add-row: 
    * delete-row:

<!-- A schema's header is basically its `keyof`. From this we can: -->

***

## References

Most of this post (except for the thoughts on typing tables) is a rephrasing and summary of the following:

* [Structural Typing - Wikipedia](https://en.wikipedia.org/wiki/Structural_type_system)
* [Nominal Typing - Wikipedia](https://en.wikipedia.org/wiki/Nominal_type_system)
* [Type Compatability - TypeScript Handbook](https://www.TypeScriptlang.org/docs/handbook/type-compatibility.html)
* [Nominal and Structural Typing](http://wiki.c2.com/?NominativeAndStructuralTyping)
* [Nominal Typing Proposal TypeScript](https://github.com/Microsoft/TypeScript/issues/202)
* [Comparison of Programming Languages by Type System - Wikipedia](https://en.wikipedia.org/wiki/https://www.oracle.com/technical-resources/articles/java/javareflection.html)
* [Using Reflection in Java](https://www.oracle.com/technical-resources/articles/java/javareflection.html)
* [Implementing an Interface in Java](https://docs.oracle.com/javase/tutorial/java/IandI/usinginterface.html)
* [KeyOf TypeScript](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [Types vs. Interface in TypeScript](https://blog.bitsrc.io/type-vs-interface-in-typescript-cf3c00bc04ae)
* [How to use KeyOf Operator in TypeScript](https://blog.logrocket.com/how-to-use-keyof-operator-typescript/)
* [5 ways to use `keyof` operator in TypeScript](https://byby.dev/ts-keyof)
* [Stackoverflow question about `extend keyof` and `in keyof`](https://stackoverflow.com/questions/57337598/in-typescript-what-do-extends-keyof-and-in-keyof-mean)
* [keyof and Lookup Types in TypeScript](https://mariusschulz.com/blog/keyof-and-lookup-types-in-typescript)
* [Mapped Types in TypeScript](https://mariusschulz.com/blog/mapped-types-in-typescript#modeling-object-freeze-with-mapped-types)
* [Types and Programming Languages - Benjamin C. Pierce - 19.3](https://www.cis.upenn.edu/~bcpierce/tapl/)
* [Utility Type - TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [Unions and Intersection Types - TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)
* [Types for Tables: A Language Design Benchmark](https://cs.brown.edu/~sk/Publications/Papers/Published/lgk-b2t2/paper.pdf)
* [B2T2 Typescript Implementation](https://github.com/brownplt/B2T2/tree/main/Media/TypeScript)
